/**
 * ...
 * @author Away3D Team - http://away3d.com/team/ (Original Development)
 * @author Karim Beyrouti - http://kurst.co.uk/ (ActionScript to TypeScript port)
 * @author Gary Paluk - http://www.plugin.io/ (ActionScript to TypeScript port)
 * @author Pete Shand - http://www.peteshand.net/ (TypeScript to Randori port)
 */

package away.base
{
	import away.display3D.IndexBuffer3D;
	import away.display3D.Context3D;
	import away.managers.Stage3DProxy;
	import away.utils.VectorInit;
	import away.display3D.VertexBuffer3D;
	import away.errors.AbstractMethodError;
	import away.geom.Matrix3D;
	import away.geom.Vector3D;
	import away.utils.VectorInit;
    /**     * @class away.base.SubGeometryBase     */
	public class SubGeometryBase
	{
		public var _parentGeometry:Geometry;
        public var _vertexData:Vector.<Number>;

        public var _faceNormalsDirty:Boolean = true;
        public var _faceTangentsDirty:Boolean = true;
        public var _faceTangents:Vector.<Number>;
        public var _indices:Vector.<Number>;/*uint*/
        public var _indexBuffer:Vector.<IndexBuffer3D> = VectorInit.AnyClass(IndexBuffer3D, 8);//Vector.<IndexBuffer3D> = VectorInit.AnyClass(IndexBuffer3D, 8)
        public var _numIndices:Number = 0;
        public var _indexBufferContext:Vector.<Context3D> = VectorInit.AnyClass(Context3D, 8);//Vector.<Context3D> = VectorInit.AnyClass(Context3D, 8)
        public var _indicesInvalid:Vector.<Boolean> = VectorInit.Bool( 8 );//VectorInit.Bool(8, true)
        public var _numTriangles:Number = 0;

        public var _autoDeriveVertexNormals:Boolean = true;
        public var _autoDeriveVertexTangents:Boolean = true;
        public var _autoGenerateUVs:Boolean = false;
        public var _useFaceWeights:Boolean = false;
        public var _vertexNormalsDirty:Boolean = true;
        public var _vertexTangentsDirty:Boolean = true;

        public var _faceNormals:Vector.<Number>;
        public var _faceWeights:Vector.<Number>;
        public var _scaleU:Number = 1;
        public var _scaleV:Number = 1;
        public var _uvsDirty:Boolean = true;
		
		public function SubGeometryBase():void
		{
		}
		
		/**		 * Defines whether a UV buffer should be automatically generated to contain dummy UV coordinates.		 * Set to true if a geometry lacks UV data but uses a material that requires it, or leave as false		 * in cases where UV data is explicitly defined or the material does not require UV data.		 */
		public function get autoGenerateDummyUVs():Boolean
		{
			return this._autoGenerateUVs;
		}
		
		public function set autoGenerateDummyUVs(value:Boolean):void
		{
            this._autoGenerateUVs = value;
            this._uvsDirty = value;
		}
		
		/**		 * True if the vertex normals should be derived from the geometry, false if the vertex normals are set		 * explicitly.		 */
		public function get autoDeriveVertexNormals():Boolean
		{
			return this._autoDeriveVertexNormals;
		}
		
		public function set autoDeriveVertexNormals(value:Boolean):void
		{
            this._autoDeriveVertexNormals = value;
            this._vertexNormalsDirty = value;
		}
		
		/**		 * Indicates whether or not to take the size of faces into account when auto-deriving vertex normals and tangents.		 */
		public function get useFaceWeights():Boolean
		{
			return this._useFaceWeights;
		}
		
		public function set useFaceWeights(value:Boolean):void
		{

            this._useFaceWeights = value;

			if (this._autoDeriveVertexNormals)
            {
                this._vertexNormalsDirty = true;
            }

			if (this._autoDeriveVertexTangents)
            {
                this._vertexTangentsDirty = true;
            }

            this._faceNormalsDirty = true;

		}
		
		/**		 * The total amount of triangles in the SubGeometry.		 */
		public function get numTriangles():Number
		{
			return this._numTriangles;
		}
		
		/**		 * Retrieves the VertexBuffer3D object that contains triangle indices.		 * @param context The Context3D for which we request the buffer		 * @return The VertexBuffer3D object that contains triangle indices.		 */
		public function getIndexBuffer(stage3DProxy:Stage3DProxy):IndexBuffer3D
		{
			var contextIndex:Number = stage3DProxy._iStage3DIndex;//_stage3DIndex;
			var context:Context3D = stage3DProxy._iContext3D;//_context3D;
			
			if (!this._indexBuffer[contextIndex] || this._indexBufferContext[contextIndex] != context)
            {
                this._indexBuffer[contextIndex] = context.createIndexBuffer(this._numIndices);
                this._indexBufferContext[contextIndex] = context;
                this._indicesInvalid[contextIndex] = true;
			}

			if (this._indicesInvalid[contextIndex])
            {
                this._indexBuffer[contextIndex].uploadFromArray(this._indices, 0, this._numIndices);
                this._indicesInvalid[contextIndex] = false;
			}
			
			return this._indexBuffer[contextIndex];
		}
		
		/**		 * Updates the tangents for each face.		 */
		public function pUpdateFaceTangents():void
		{
			var i:Number = 0;
			var index1:Number;
            var index2:Number;
            var index3:Number;
			var len:Number = this._indices.length;
			var ui:Number;
            var vi:Number;
			var v0:Number;
			var dv1:Number;
            var dv2:Number;
			var denom:Number;
			var x0:Number, y0:Number, z0:Number;
			var dx1:Number, dy1:Number, dz1:Number;
			var dx2:Number, dy2:Number, dz2:Number;
			var cx:Number, cy:Number, cz:Number;
			var vertices:Vector.<Number> = this._vertexData;
			var uvs:Vector.<Number> = this.UVData;
			var posStride:Number = this.vertexStride;
			var posOffset:Number = this.vertexOffset;
			var texStride:Number = this.UVStride;
			var texOffset:Number = this.UVOffset;

            if ( this._faceTangents == null)
            {
                this._faceTangents = VectorInit.Num( this._indices.length ); //||= new Vector.<Number>(_indices.length, true);
            }

			while (i < len)
            {
				index1 = this._indices[i];
				index2 = this._indices[i + 1];
				index3 = this._indices[i + 2];
				
				ui = texOffset + index1*texStride + 1;
				v0 = uvs[ui];
				ui = texOffset + index2*texStride + 1;
				dv1 = uvs[ui] - v0;
				ui = texOffset + index3*texStride + 1;
				dv2 = uvs[ui] - v0;
				
				vi = posOffset + index1*posStride;
				x0 = vertices[vi];
				y0 = vertices[(vi + 1)];
				z0 = vertices[(vi + 2)];
				vi = posOffset + index2*posStride;
				dx1 = vertices[(vi)] - x0;
				dy1 = vertices[(vi + 1)] - y0;
				dz1 = vertices[(vi + 2)] - z0;
				vi = posOffset + index3*posStride;
				dx2 = vertices[(vi)] - x0;
				dy2 = vertices[(vi + 1)] - y0;
				dz2 = vertices[(vi + 2)] - z0;
				
				cx = dv2*dx1 - dv1*dx2;
				cy = dv2*dy1 - dv1*dy2;
				cz = dv2*dz1 - dv1*dz2;
				denom = 1/Math.sqrt(cx*cx + cy*cy + cz*cz);

				this._faceTangents[i++] = denom*cx;
                this._faceTangents[i++] = denom*cy;
                this._faceTangents[i++] = denom*cz;
			}

            this._faceTangentsDirty = false;

		}
		
		/**		 * Updates the normals for each face.		 */
		private function updateFaceNormals():void
		{
			var i:Number = 0;
            var j:Number = 0;
            var k:Number = 0;
			var index:Number;

			var len:Number = this._indices.length;
			var x1:Number, x2:Number, x3:Number;
			var y1:Number, y2:Number, y3:Number;
			var z1:Number, z2:Number, z3:Number;
			var dx1:Number, dy1:Number, dz1:Number;
			var dx2:Number, dy2:Number, dz2:Number;
			var cx:Number, cy:Number, cz:Number;
			var d:Number;
			var vertices:Vector.<Number> = this._vertexData;
			var posStride:Number = this.vertexStride;
			var posOffset:Number = this.vertexOffset;

            if ( this._faceNormals == null )
            {
                this._faceNormals = VectorInit.Num( len );//_faceNormals ||= new Vector.<Number>(len, true);
            }

			if ( this._useFaceWeights )
            {
                if ( this._faceWeights == null )
                {
                    this._faceWeights = VectorInit.Num( len / 3 );//_faceWeights ||= new Vector.<Number>(len/3, true);
                }
            }

			while (i < len)
            {
				index = posOffset + this._indices[i++]*posStride;
				x1 = vertices[index];
				y1 = vertices[index + 1];
				z1 = vertices[index + 2];
				index = posOffset + this._indices[i++]*posStride;
				x2 = vertices[index];
				y2 = vertices[index + 1];
				z2 = vertices[index + 2];
				index = posOffset + this._indices[i++]*posStride;
				x3 = vertices[index];
				y3 = vertices[index + 1];
				z3 = vertices[index + 2];
				dx1 = x3 - x1;
				dy1 = y3 - y1;
				dz1 = z3 - z1;
				dx2 = x2 - x1;
				dy2 = y2 - y1;
				dz2 = z2 - z1;
				cx = dz1*dy2 - dy1*dz2;
				cy = dx1*dz2 - dz1*dx2;
				cz = dy1*dx2 - dx1*dy2;
				d = Math.sqrt(cx*cx + cy*cy + cz*cz);
				// length of cross product = 2*triangle area

				if (this._useFaceWeights)
                {
					var w:Number = d*10000;

					if (w < 1)
                    {
                        w = 1;
                    }

                    this._faceWeights[k++] = w;
				}

				d = 1/d;

				this._faceNormals[j++] = cx*d;
                this._faceNormals[j++] = cy*d;
                this._faceNormals[j++] = cz*d;
			}

            this._faceNormalsDirty = false;

		}
		
		/**		 * Updates the vertex normals based on the geometry.		 */
		public function pUpdateVertexNormals(target:Vector.<Number>):Vector.<Number>
		{
			if (this._faceNormalsDirty)
            {
                this.updateFaceNormals();
            }

			var v1:Number;
			var f1:Number = 0;
            var f2:Number = 1;
            var f3:Number = 2;
			var lenV:Number = this._vertexData.length;
			var normalStride:Number = this.vertexNormalStride;
			var normalOffset:Number = this.vertexNormalOffset;

            if ( target == null )
            {

                target = VectorInit.Num( lenV );//target ||= new Vector.<Number>(lenV, true);

            }

			v1 = normalOffset;

			while (v1 < lenV)
            {
				target[v1] = 0.0;
				target[v1 + 1] = 0.0;
				target[v1 + 2] = 0.0;
				v1 += normalStride;
			}
			
			var i:Number = 0;
            var k:Number = 0;
			var lenI:Number = this._indices.length;
			var index:Number;
			var weight:Number;
			
			while (i < lenI)
            {
				weight = this._useFaceWeights? this._faceWeights[k++] : 1;
				index = normalOffset + this._indices[i++]*normalStride;
				target[index++] += this._faceNormals[f1]*weight;
				target[index++] += this._faceNormals[f2]*weight;
				target[index] += this._faceNormals[f3]*weight;
				index = normalOffset + this._indices[i++]*normalStride;
				target[index++] += this._faceNormals[f1]*weight;
				target[index++] += this._faceNormals[f2]*weight;
				target[index] += this._faceNormals[f3]*weight;
				index = normalOffset + this._indices[i++]*normalStride;
				target[index++] += this._faceNormals[f1]*weight;
				target[index++] += this._faceNormals[f2]*weight;
				target[index] += this._faceNormals[f3]*weight;
				f1 += 3;
				f2 += 3;
				f3 += 3;
			}
			
			v1 = normalOffset;
			while (v1 < lenV)
            {
				var vx:Number = target[v1];
				var vy:Number = target[v1 + 1];
				var vz:Number = target[v1 + 2];
				var d:Number = 1.0/Math.sqrt(vx*vx + vy*vy + vz*vz);
				target[v1] = vx*d;
				target[v1 + 1] = vy*d;
				target[v1 + 2] = vz*d;
				v1 += normalStride;
			}
			
			this._vertexNormalsDirty = false;
			
			return target;
		}
		
		/**		 * Updates the vertex tangents based on the geometry.		 */
		public function pUpdateVertexTangents(target:Vector.<Number>):Vector.<Number>
		{
			if ( this._faceTangentsDirty )
            {
                this.pUpdateFaceTangents()//updateFaceTangents();
            }

			var i:Number;
			var lenV:Number = this._vertexData.length;
			var tangentStride:Number = this.vertexTangentStride;
			var tangentOffset:Number = this.vertexTangentOffset;

            if ( target == null )
            {

                target = VectorInit.Num( lenV ); //target ||= new Vector.<Number>(lenV, true);
            }

			
			i = tangentOffset;

			while (i < lenV)
            {

				target[i] = 0.0;
				target[i + 1] = 0.0;
				target[i + 2] = 0.0;
				i += tangentStride;

			}
			
			var k:Number = 0;
			var lenI:Number = this._indices.length;
			var index:Number;
			var weight:Number;
			var f1:Number = 0;
            var f2:Number = 1;
            var f3:Number = 2;
			
			i = 0;
			
			while (i < lenI)
            {
				weight =this._useFaceWeights? this._faceWeights[k++] : 1;
				index = tangentOffset + this._indices[i++]*tangentStride;
				target[index++] += this._faceTangents[f1]*weight;
				target[index++] += this._faceTangents[f2]*weight;
				target[index] += this._faceTangents[f3]*weight;
				index = tangentOffset + this._indices[i++]*tangentStride;
				target[index++] += this._faceTangents[f1]*weight;
				target[index++] += this._faceTangents[f2]*weight;
				target[index] += this._faceTangents[f3]*weight;
				index = tangentOffset + this._indices[i++]*tangentStride;
				target[index++] += this._faceTangents[f1]*weight;
				target[index++] += this._faceTangents[f2]*weight;
				target[index] += this._faceTangents[f3]*weight;
				f1 += 3;
				f2 += 3;
				f3 += 3;
			}
			
			i = tangentOffset;

			while (i < lenV)
            {
				var vx:Number = target[i];
				var vy:Number = target[i + 1];
				var vz:Number = target[i + 2];
				var d:Number = 1.0/Math.sqrt(vx*vx + vy*vy + vz*vz);
				target[i] = vx*d;
				target[i + 1] = vy*d;
				target[i + 2] = vz*d;
				i += tangentStride;
			}

            this._vertexTangentsDirty = false;
			
			return target;
		}
		
		public function dispose():void
		{
			this.pDisposeIndexBuffers(this._indexBuffer);
            this._indices = null;
            this._indexBufferContext = null;
            this._faceNormals = null;
            this._faceWeights = null;
            this._faceTangents = null;
            this._vertexData = null;
		}
		
		/**		 * The raw index data that define the faces.		 *		 * @private		 */
		public function get indexData():Vector.<Number> /*uint*/		{
			return this._indices;
		}
		
		/**		 * Updates the face indices of the SubGeometry.		 * @param indices The face indices to upload.		 */
		public function updateIndexData(indices:Vector.<Number>/*uint*/):void
		{
            this._indices = indices;
            this._numIndices = indices.length;
			
			var numTriangles:Number = this._numIndices/3;

			if (this._numTriangles != numTriangles)
            {
                this.pDisposeIndexBuffers(this._indexBuffer);
            }

			this._numTriangles = numTriangles;
            this.pInvalidateBuffers(this._indicesInvalid);
            this._faceNormalsDirty = true;
			
			if (this._autoDeriveVertexNormals)
            {
                this._vertexNormalsDirty = true;
            }

			if (this._autoDeriveVertexTangents)
            {
                this._vertexTangentsDirty = true;
            }

		}
		
		/**		 * Disposes all buffers in a given vector.		 * @param buffers The vector of buffers to dispose.		 */
		public function pDisposeIndexBuffers(buffers:Vector.<IndexBuffer3D>):void //Vector.<IndexBuffer3D>)		{
			for (var i:Number = 0; i < 8; ++i)
            {
				if (buffers[i])
                {
					buffers[i].dispose();
					buffers[i] = null;
				}
			}
		}
		
		/**		 * Disposes all buffers in a given vector.		 * @param buffers The vector of buffers to dispose.		 */
		public function pDisposeVertexBuffers(buffers:Vector.<VertexBuffer3D>):void //Vector.<VertexBuffer3D>)		{
			for (var i:Number = 0; i < 8; ++i)
            {
				if (buffers[i])
                {
					buffers[i].dispose();
					buffers[i] = null;
				}
			}
		}
		
		/**		 * True if the vertex tangents should be derived from the geometry, false if the vertex normals are set		 * explicitly.		 */
		public function get autoDeriveVertexTangents():Boolean
		{
			return this._autoDeriveVertexTangents;
		}
		
		public function set autoDeriveVertexTangents(value:Boolean):void
		{
            this._autoDeriveVertexTangents = value;
            this._vertexTangentsDirty = value;
		}
		
		/**		 * The raw data of the face normals, in the same order as the faces are listed in the index list.		 *		 * @private		 */
		public function get faceNormals():Vector.<Number>
		{
			if (this._faceNormalsDirty)
            {
                this.updateFaceNormals();
            }

			return this._faceNormals;
		}
		
		/**		 * Invalidates all buffers in a vector, causing them the update when they are first requested.		 * @param buffers The vector of buffers to invalidate.		 */
		public function pInvalidateBuffers(invalid:Vector.<Boolean>):void
		{
			for (var i:Number = 0; i < 8; ++i)
            {
                invalid[i] = true;
            }
		}
		
		public function get UVStride():Number
		{
			throw new AbstractMethodError();//AbstractMethodError();
		}
		
		public function get vertexData():Vector.<Number>
		{
            throw new AbstractMethodError();//
		}
		
		public function get vertexPositionData():Vector.<Number>
		{
            throw new AbstractMethodError();//
		}
		
		public function get vertexNormalData():Vector.<Number>
		{
            throw new AbstractMethodError();//
		}
		
		public function get vertexTangentData():Vector.<Number>
		{
            throw new AbstractMethodError();//
		}
		
		public function get UVData():Vector.<Number>
		{
            throw new AbstractMethodError();//
		}
		
		public function get vertexStride():Number
		{
            throw new AbstractMethodError();//
		}
		
		public function get vertexNormalStride():Number
		{
            throw new AbstractMethodError();//
		}
		
		public function get vertexTangentStride():Number
		{
            throw new AbstractMethodError();//
		}
		
		public function get vertexOffset():Number
		{
            throw new AbstractMethodError();//
		}
		
		public function get vertexNormalOffset():Number
		{
            throw new AbstractMethodError();//
		}
		
		public function get vertexTangentOffset():Number
		{
            throw new AbstractMethodError();//
		}
		
		public function get UVOffset():Number
		{
            throw new AbstractMethodError();//
		}
		
		public function pInvalidateBounds():void
		{
			if (this._parentGeometry)
            {
                var me : *  = this;
                this._parentGeometry.iInvalidateBounds( (me as ISubGeometry) );
            }

		}
		
		/**		 * The Geometry object that 'owns' this SubGeometry object.		 *		 * @private		 */
		public function get parentGeometry():Geometry
		{
			return this._parentGeometry;
		}
		
		public function set parentGeometry(value:Geometry):void
		{
			this._parentGeometry = value;
		}
		
		/**		 * Scales the uv coordinates		 * @param scaleU The amount by which to scale on the u axis. Default is 1;		 * @param scaleV The amount by which to scale on the v axis. Default is 1;		 */
		public function get scaleU():Number
		{
			return this._scaleU;
		}
		
		public function get scaleV():Number
		{
			return this._scaleV;
		}
		
		public function scaleUV(scaleU:Number = 1, scaleV:Number = 1):void
		{
			scaleU = scaleU || 1;
			scaleV = scaleV || 1;

			var offset:Number = this.UVOffset;
			var stride:Number = this.UVStride;
			var uvs:Vector.<Number> = this.UVData;
			var len:Number = uvs.length;
			var ratioU:Number = scaleU/this._scaleU;
			var ratioV:Number = scaleV/this._scaleV;
			
			for (var i:Number = offset; i < len; i += stride)
            {
				uvs[i] *= ratioU;
				uvs[i + 1] *= ratioV;
			}

            this._scaleU = scaleU;
            this._scaleV = scaleV;
		}
		
		/**		 * Scales the geometry.		 * @param scale The amount by which to scale.		 */
		public function scale(scale:Number):void
		{
			var vertices:Vector.<Number> = this.UVData;
			var len:Number = vertices.length;
			var offset:Number = this.vertexOffset;
			var stride:Number = this.vertexStride;
			
			for (var i:Number = offset; i < len; i += stride)
            {
				vertices[i] *= scale;
				vertices[i + 1] *= scale;
				vertices[i + 2] *= scale;
			}
		}
		
		public function applyTransformation(transform:Matrix3D):void
		{
			var vertices:Vector.<Number> = this._vertexData;
			var normals:Vector.<Number> = this.vertexNormalData;
			var tangents:Vector.<Number> = this.vertexTangentData;
			var posStride:Number = this.vertexStride;
			var normalStride:Number = this.vertexNormalStride;
			var tangentStride:Number = this.vertexTangentStride;
			var posOffset:Number = this.vertexOffset;
			var normalOffset:Number = this.vertexNormalOffset;
			var tangentOffset:Number = this.vertexTangentOffset;
			var len:Number = vertices.length/posStride;
			var i:Number;
            var i1:Number;
            var i2:Number;
			var vector:Vector3D = new Vector3D();
			
			var bakeNormals:Boolean = normals != null;
			var bakeTangents:Boolean = tangents != null;
			var invTranspose:Matrix3D;
			
			if (bakeNormals || bakeTangents)
            {
				invTranspose = transform.clone();
				invTranspose.invert();
				invTranspose.transpose();
			}
			
			var vi0:Number = posOffset;
			var ni0:Number = normalOffset;
			var ti0:Number = tangentOffset;
			
			for (i = 0; i < len; ++i)
            {
				i1 = vi0 + 1;
				i2 = vi0 + 2;
				
				// bake position
				vector.x = vertices[vi0];
				vector.y = vertices[i1];
				vector.z = vertices[i2];
				vector = transform.transformVector(vector);
				vertices[vi0] = vector.x;
				vertices[i1] = vector.y;
				vertices[i2] = vector.z;
				vi0 += posStride;
				
				// bake normal
				if (bakeNormals)
                {
					i1 = ni0 + 1;
					i2 = ni0 + 2;
					vector.x = normals[ni0];
					vector.y = normals[i1];
					vector.z = normals[i2];
					vector = invTranspose.deltaTransformVector(vector);
					vector.normalize();
					normals[ni0] = vector.x;
					normals[i1] = vector.y;
					normals[i2] = vector.z;
					ni0 += normalStride;
				}
				
				// bake tangent
				if (bakeTangents)
                {
					i1 = ti0 + 1;
					i2 = ti0 + 2;
					vector.x = tangents[ti0];
					vector.y = tangents[i1];
					vector.z = tangents[i2];
					vector = invTranspose.deltaTransformVector(vector);
					vector.normalize();
					tangents[ti0] = vector.x;
					tangents[i1] = vector.y;
					tangents[i2] = vector.z;
					ti0 += tangentStride;
				}
			}
		}
		
		public function pUpdateDummyUVs(target:Vector.<Number>):Vector.<Number>
		{
			this._uvsDirty = false;
            var idx:Number;
            var uvIdx:Number;
			var stride:Number = this.UVStride;
			var skip:Number = stride - 2;
			var len:Number = this._vertexData.length/this.vertexStride*stride;
			
			if (!target)
            {
                target = VectorInit.Num();
            }

			target.length = len;

			idx = this.UVOffset;
			uvIdx = 0;

			while (idx < len)
            {
				target[idx++] = uvIdx*.5;
				target[idx++] = 1.0 - (uvIdx & 1);
				idx += skip;
				
				if (++uvIdx == 3)
                {
					uvIdx = 0;
                }
			}
			
			return target;

		}
	}
}
